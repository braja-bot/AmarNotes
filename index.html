import React, { useState, useEffect, Component } from 'react';
import { 
  Upload, Check, X, Sliders, Layout, 
  Printer, Download, RefreshCw, Moon, Sun, 
  Layers, ChevronRight, FileText, AlertTriangle,
  Grid, Image as ImageIcon, Trash2, Home, Crop
} from 'lucide-react';

// --- CONFIGURATION ---
const PDFJS_URL = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js";
const PDFJS_WORKER_URL = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
const JSPDF_URL = "https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js";

const STEPS = [
  { id: 1, label: "Upload", icon: Upload },
  { id: 2, label: "Select", icon: Layers },
  { id: 3, label: "Enhance", icon: Sliders },
  { id: 4, label: "Layout", icon: Layout },
  { id: 5, label: "Process", icon: RefreshCw },
  { id: 6, label: "Finish", icon: Download },
];

const A4_WIDTH_LANDSCAPE = 297; 
const A4_HEIGHT_LANDSCAPE = 210;
const A4_WIDTH_PORTRAIT = 210;
const A4_HEIGHT_PORTRAIT = 297;

// --- UTILITY: SCRIPT LOADER ---
const loadScript = (src) => {
  return new Promise((resolve, reject) => {
    if (document.querySelector(`script[src="${src}"]`)) {
      resolve();
      return;
    }
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
};

// --- UTILITY: IMAGE PROCESSING ENGINE (UHD) ---
const processImageFilters = (ctx, width, height, filters) => {
  const imgData = ctx.getImageData(0, 0, width, height);
  const data = imgData.data;

  for (let i = 0; i < data.length; i += 4) {
    let r = data[i];
    let g = data[i + 1];
    let b = data[i + 2];
    
    // 1. SMART INVERT (Enhanced for Smoothness)
    if (filters.invert) {
      r = 255 - r;
      g = 255 - g;
      b = 255 - b;

      // Smart Leveling with "Soft Knee" to preserve anti-aliasing
      // Pure White Background
      if (r > 230 && g > 230 && b > 230) {
          r = 255; g = 255; b = 255;
      }
      // Deep Black Text
      else if (r < 50 && g < 50 && b < 50) {
          r = 0; g = 0; b = 0;
      }
    }

    // 2. GRAYSCALE (Luminosity)
    if (filters.grayscale) {
      const avg = 0.299 * r + 0.587 * g + 0.114 * b;
      r = avg;
      g = avg;
      b = avg;
    }

    // 3. HIGH CONTRAST (Gamma Correction - High Fidelity)
    if (filters.highContrast) {
        // Normalize
        let nr = r / 255;
        let ng = g / 255;
        let nb = b / 255;

        // Apply Gamma 1.2 (Subtle boost, preserves details)
        nr = Math.pow(nr, 1.2);
        ng = Math.pow(ng, 1.2);
        nb = Math.pow(nb, 1.2);

        // Scale back
        r = nr * 255;
        g = ng * 255;
        b = nb * 255;
    }
    
    // 4. REMOVE BACKGROUND
    if (filters.removeBg) {
      if (r > 210 && g > 210 && b > 210) {
        r = 255; g = 255; b = 255;
      }
    }

    data[i] = r;
    data[i + 1] = g;
    data[i + 2] = b;
  }
  
  ctx.putImageData(imgData, 0, 0);
};

// --- ALGORITHM: SMART CROP ---
const detectContentBoundingBox = (ctx, width, height) => {
    const imgData = ctx.getImageData(0, 0, width, height);
    const data = imgData.data;
    let minX = width, minY = height, maxX = 0, maxY = 0;
    let foundContent = false;
    const stride = 5; 

    for (let y = 0; y < height; y += stride) {
        for (let x = 0; x < width; x += stride) {
            const i = (y * width + x) * 4;
            // Threshold 245 catches standard light gray/artifacts
            if (data[i] < 245 || data[i+1] < 245 || data[i+2] < 245) {
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
                foundContent = true;
            }
        }
    }

    if (!foundContent) return null;
    const padding = 15; 
    return {
        x: Math.max(0, minX - padding),
        y: Math.max(0, minY - padding),
        w: Math.min(width - minX + padding, (maxX - minX) + (padding * 2)),
        h: Math.min(height - minY + padding, (maxY - minY) + (padding * 2))
    };
};

// --- ERROR BOUNDARY ---
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) { return { hasError: true }; }
  render() {
    if (this.state.hasError) return (
        <div className="min-h-screen bg-slate-950 flex items-center justify-center text-white">
            <div className="text-center">
                <AlertTriangle className="w-12 h-12 text-red-500 mx-auto mb-2"/>
                <h2>Application Error</h2>
                <p className="text-slate-400 text-sm mb-4">Memory limit exceeded. Try fewer pages.</p>
                <button onClick={() => window.location.reload()} className="bg-red-600 px-6 py-2 rounded-lg">Reload</button>
            </div>
        </div>
    );
    return this.props.children;
  }
}

// --- SUB-COMPONENTS ---

const StepIndicator = ({ currentStep }) => (
  <div className="w-full max-w-4xl mx-auto mb-8 px-4">
    <div className="flex items-center justify-between relative">
      <div className="absolute left-0 top-1/2 transform -translate-y-1/2 w-full h-1 bg-slate-800 -z-10 rounded"></div>
      <div 
        className="absolute left-0 top-1/2 transform -translate-y-1/2 h-1 bg-violet-600 -z-10 transition-all duration-500 rounded"
        style={{ width: `${((currentStep - 1) / (STEPS.length - 1)) * 100}%` }}
      ></div>
      {STEPS.map((step) => {
        const Icon = step.icon;
        const isActive = step.id <= currentStep;
        const isCurrent = step.id === currentStep;
        return (
          <div key={step.id} className="flex flex-col items-center gap-2">
            <div className={`w-8 h-8 md:w-10 md:h-10 rounded-full flex items-center justify-center transition-all duration-300 border-2 z-10 ${isActive ? 'bg-violet-600 border-violet-600 text-white scale-110' : 'bg-slate-900 border-slate-700 text-slate-500'}`}>
              <Icon size={16} className={isCurrent ? "animate-pulse" : ""} />
            </div>
            <span className={`text-[10px] md:text-xs font-medium uppercase tracking-wider ${isCurrent ? 'text-violet-400' : 'text-slate-500'} hidden sm:block`}>{step.label}</span>
          </div>
        );
      })}
    </div>
  </div>
);

const FilterCard = ({ label, desc, icon: Icon, active, onClick, colorClass, badge }) => (
  <div onClick={onClick} className={`relative p-5 rounded-2xl border cursor-pointer transition-all duration-300 flex items-start gap-4 overflow-hidden group ${active ? `bg-slate-800 border-${colorClass}-500 shadow-lg shadow-${colorClass}-900/20` : 'bg-slate-900/50 border-slate-700 hover:bg-slate-800'}`}>
    <div className={`w-12 h-12 rounded-xl flex items-center justify-center transition-colors shrink-0 ${active ? `bg-${colorClass}-500/20 text-${colorClass}-400` : 'bg-slate-800 text-slate-500'}`}>
      <Icon size={24} />
    </div>
    <div className="flex-1">
      <div className="flex justify-between items-center mb-1">
        <h4 className={`font-semibold ${active ? 'text-white' : 'text-slate-300'}`}>
            {label} 
            {badge && <span className="ml-2 text-[10px] bg-violet-600 text-white px-2 py-0.5 rounded-full">{badge}</span>}
        </h4>
        {active && <div className={`w-3 h-3 rounded-full bg-${colorClass}-500 shadow-[0_0_8px_currentColor]`} />}
      </div>
      <p className="text-xs text-slate-500 leading-relaxed">{desc}</p>
    </div>
    {active && <div className={`absolute -right-10 -bottom-10 w-32 h-32 bg-${colorClass}-500/10 blur-3xl rounded-full`} />}
  </div>
);

const LayoutOption = ({ rows, cols, label, currentLayout, onSelect }) => {
  const isActive = currentLayout.rows === rows && currentLayout.cols === cols;
  return (
    <button onClick={() => onSelect({ ...currentLayout, rows, cols })} className={`relative p-4 rounded-2xl border transition-all duration-200 flex flex-col items-center gap-3 group ${isActive ? 'bg-violet-600/10 border-violet-500' : 'bg-slate-900 border-slate-800 hover:border-slate-600'}`}>
      <div className={`w-16 h-20 grid gap-1 p-1 rounded border ${isActive ? 'bg-violet-900/20 border-violet-500/30' : 'bg-slate-800 border-slate-700'}`} style={{ gridTemplateColumns: `repeat(${cols}, 1fr)`, gridTemplateRows: `repeat(${rows}, 1fr)` }}>
          {Array.from({ length: rows * cols }).map((_, i) => (<div key={i} className={`rounded-sm ${isActive ? 'bg-violet-500/40' : 'bg-slate-600/40'}`} />))}
      </div>
      <span className={`text-sm font-medium ${isActive ? 'text-violet-400' : 'text-slate-400 group-hover:text-slate-300'}`}>{label}</span>
      {isActive && <div className="absolute top-3 right-3 w-4 h-4 bg-violet-500 rounded-full shadow-lg shadow-violet-500/50" />}
    </button>
  );
};

// --- MAIN CONTENT ---
function AmarNotesContent() {
  const [libsLoaded, setLibsLoaded] = useState(false);
  const [currentStep, setCurrentStep] = useState(1);
  const [pdfDoc, setPdfDoc] = useState(null);
  const [pages, setPages] = useState([]); 
  const [processingProgress, setProcessingProgress] = useState({ current: 0, total: 0, status: '' });
  const [finalPdfUrl, setFinalPdfUrl] = useState(null);
  const [finalMeta, setFinalMeta] = useState({ pages: 0, size: 0 });
  const [generationStatus, setGenerationStatus] = useState("");

  const [filters, setFilters] = useState({
    invert: false,
    grayscale: false,
    highContrast: false,
    removeBg: false,
    smartCrop: false
  });
  
  const [layout, setLayout] = useState({
    rows: 2, cols: 2, showLines: true, showPageNums: true, orientation: 'landscape', gap: 4
  });

  useEffect(() => {
    const initLibs = async () => {
      try {
        await Promise.all([loadScript(PDFJS_URL), loadScript(JSPDF_URL)]);
        const checkInterval = setInterval(() => {
          if (window.pdfjsLib && window.jspdf) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = PDFJS_WORKER_URL;
            setLibsLoaded(true);
            clearInterval(checkInterval);
          }
        }, 100);
        setTimeout(() => clearInterval(checkInterval), 10000);
      } catch (err) {
        console.error("Library Load Error", err);
      }
    };
    initLibs();
  }, []);

  const handleFileUpload = async (e) => {
    if (!libsLoaded) return;
    const uploadedFile = e.target.files[0];
    if (uploadedFile && uploadedFile.type === 'application/pdf') {
      setProcessingProgress({ current: 0, total: 100, status: 'Parsing PDF...' });
      try {
        const arrayBuffer = await uploadedFile.arrayBuffer();
        const loadingTask = window.pdfjsLib.getDocument({ data: arrayBuffer });
        const doc = await loadingTask.promise;
        setPdfDoc(doc);
        const pageMap = Array.from({ length: doc.numPages }, (_, i) => ({ index: i + 1, selected: true, previewUrl: null }));
        setPages(pageMap);
        setCurrentStep(2);
        generateThumbnails(doc, pageMap);
      } catch (err) {
        alert("Failed to read PDF.");
      }
    }
  };

  const generateThumbnails = async (doc, pageMap) => {
    const newPages = [...pageMap];
    setGenerationStatus("Generating Previews...");
    for (let i = 0; i < doc.numPages; i++) {
        try {
          const page = await doc.getPage(i + 1);
          const viewport = page.getViewport({ scale: 0.2 }); 
          const canvas = document.createElement('canvas');
          const context = canvas.getContext('2d');
          canvas.height = viewport.height; canvas.width = viewport.width;
          await page.render({ canvasContext: context, viewport: viewport }).promise;
          newPages[i].previewUrl = canvas.toDataURL();
          canvas.width = 0; canvas.height = 0;
          if (i % 5 === 0) {
              setPages([...newPages]);
              await new Promise(r => setTimeout(r, 0));
          }
        } catch (e) {}
    }
    setPages([...newPages]);
    setGenerationStatus(""); 
  };

  const togglePage = (index) => {
    const newPages = [...pages];
    newPages[index].selected = !newPages[index].selected;
    setPages(newPages);
  };

  const executeProcessing = async () => {
    if (!libsLoaded) return;
    setCurrentStep(5);
    await new Promise(r => setTimeout(r, 100));

    try {
      const selectedPages = pages.filter(p => p.selected);
      const totalSelected = selectedPages.length;
      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ orientation: layout.orientation, unit: 'mm', format: 'a4' });

      const isLandscape = layout.orientation === 'landscape';
      const pageWidth = isLandscape ? A4_WIDTH_LANDSCAPE : A4_WIDTH_PORTRAIT;
      const pageHeight = isLandscape ? A4_HEIGHT_LANDSCAPE : A4_HEIGHT_PORTRAIT;
      const margin = 10; const gap = layout.gap;
      const effectiveWidth = pageWidth - (margin * 2); const effectiveHeight = pageHeight - (margin * 2);
      const cellWidth = (effectiveWidth - (gap * (layout.cols - 1))) / layout.cols;
      const cellHeight = (effectiveHeight - (gap * (layout.rows - 1))) / layout.rows;

      let itemsOnPage = 0;

      for (let i = 0; i < totalSelected; i++) {
        const pageObj = selectedPages[i];
        setProcessingProgress({ current: i + 1, total: totalSelected, status: `Enhancing Page ${pageObj.index}...` });

        const pdfPage = await pdfDoc.getPage(pageObj.index);
        
        // --- ULTRA HIGH DEFINITION SETTINGS ---
        // Scale 3.0 = ~220 DPI (Very Sharp for Print)
        const viewport = pdfPage.getViewport({ scale: 3.0 });
        const canvas = document.createElement('canvas');
        canvas.width = viewport.width; canvas.height = viewport.height;
        const ctx = canvas.getContext('2d');
        
        // High quality downsampling preference
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        
        await pdfPage.render({ canvasContext: ctx, viewport: viewport }).promise;

        // Apply Filters
        processImageFilters(ctx, canvas.width, canvas.height, filters);

        // Smart Crop
        let finalCanvas = canvas;
        let finalX = 0, finalY = 0, finalW = canvas.width, finalH = canvas.height;

        if (filters.smartCrop) {
           const bbox = detectContentBoundingBox(ctx, canvas.width, canvas.height);
           if (bbox) {
               finalX = bbox.x; finalY = bbox.y; finalW = bbox.w; finalH = bbox.h;
           }
        }

        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = finalW; tempCanvas.height = finalH;
        const tempCtx = tempCanvas.getContext('2d');
        // Ensure smoothing on temp canvas too
        tempCtx.imageSmoothingEnabled = true;
        tempCtx.imageSmoothingQuality = 'high';
        tempCtx.drawImage(canvas, finalX, finalY, finalW, finalH, 0, 0, finalW, finalH);

        // --- 100% QUALITY OUTPUT ---
        // '1.0' prevents JPEG compression artifacts on text edges
        const imgData = tempCanvas.toDataURL('image/jpeg', 1.0);

        const col = itemsOnPage % layout.cols;
        const row = Math.floor(itemsOnPage / layout.cols);
        const cellX = margin + (col * (cellWidth + gap));
        const cellY = margin + (row * (cellHeight + gap));

        const imgRatio = finalW / finalH;
        const cellRatio = cellWidth / cellHeight;
        let pdfW, pdfH, offsetX, offsetY;

        if (imgRatio > cellRatio) {
            pdfW = cellWidth; pdfH = cellWidth / imgRatio; offsetX = 0; offsetY = (cellHeight - pdfH) / 2;
        } else {
            pdfH = cellHeight; pdfW = cellHeight * imgRatio; offsetX = (cellWidth - pdfW) / 2; offsetY = 0;
        }

        doc.addImage(imgData, 'JPEG', cellX + offsetX, cellY + offsetY, pdfW, pdfH);
        
        if (layout.showLines) {
          doc.setDrawColor(200, 200, 200); doc.setLineWidth(0.1); doc.rect(cellX, cellY, cellWidth, cellHeight);
        }

        canvas.width = 0; canvas.height = 0; tempCanvas.width = 0; tempCanvas.height = 0;
        itemsOnPage++;
        if (itemsOnPage >= (layout.rows * layout.cols)) {
          if (i < totalSelected - 1) { doc.addPage(); itemsOnPage = 0; }
        }
        if (i % 2 === 0) await new Promise(r => setTimeout(r, 0));
      }

      if (layout.showPageNums) {
          const totalPdfPages = doc.internal.getNumberOfPages();
          doc.setFontSize(9); doc.setTextColor(100);
          for (let j = 1; j <= totalPdfPages; j++) {
              doc.setPage(j); doc.text(`Page ${j} of ${totalPdfPages} â€¢ Amar Notes`, pageWidth / 2, pageHeight - 5, { align: 'center' });
          }
      }

      const pdfBlob = doc.output('blob');
      setFinalPdfUrl(URL.createObjectURL(pdfBlob));
      setFinalMeta({ pages: doc.internal.getNumberOfPages(), size: (pdfBlob.size / 1024 / 1024).toFixed(2) });
      setCurrentStep(6);
    } catch (err) {
      setProcessingProgress({ current:0, total:0, status: 'Error occurred.' });
    }
  };

  const renderUpload = () => (
    <div className="flex flex-col items-center justify-center min-h-[400px] border-2 border-dashed border-slate-700 rounded-3xl bg-slate-900/50 hover:bg-slate-800/80 transition-all cursor-pointer relative overflow-hidden group shadow-2xl">
      <input type="file" accept=".pdf" onChange={handleFileUpload} disabled={!libsLoaded} className="absolute inset-0 opacity-0 cursor-pointer z-20"/>
      <div className="z-10 flex flex-col items-center gap-6 group-hover:scale-105 transition-transform duration-300">
        <div className="w-24 h-24 bg-violet-600/20 rounded-full flex items-center justify-center text-violet-400">
          {libsLoaded ? <Upload size={48} strokeWidth={1.5} /> : <RefreshCw size={48} className="animate-spin opacity-50"/>}
        </div>
        <div className="text-center">
          <h3 className="text-2xl font-bold text-white mb-2">{libsLoaded ? "Upload Lecture PDF" : "Loading Engine..."}</h3>
          <p className="text-slate-400 text-sm max-w-xs mx-auto">Drag & drop your slides here.</p>
        </div>
      </div>
    </div>
  );

  const renderSelect = () => (
    <div className="space-y-6 animate-in fade-in slide-in-from-bottom-4 duration-500">
      <div className="flex flex-col sm:flex-row justify-between items-center bg-slate-800/80 p-5 rounded-2xl border border-slate-700/50 backdrop-blur-sm sticky top-20 z-40 shadow-xl">
        <div>
          <h3 className="text-lg font-bold text-white flex items-center gap-2"><Layers size={18} className="text-violet-400" />Select Pages</h3>
          <p className="text-sm text-slate-400 mt-1">
            <span className="text-white font-mono">{pages.filter(p => p.selected).length}</span> selected 
            {generationStatus && <span className="ml-2 text-violet-400 animate-pulse text-xs">({generationStatus})</span>}
          </p>
        </div>
        <button onClick={() => setCurrentStep(3)} className="bg-violet-600 hover:bg-violet-700 text-white px-8 py-3 rounded-xl font-semibold flex items-center gap-2 shadow-lg shadow-violet-900/50">Next: Enhance <ChevronRight size={18} /></button>
      </div>
      <div className="grid grid-cols-2 md:grid-cols-5 gap-4 pb-20">
        {pages.map((page, idx) => (
          <div key={idx} onClick={() => togglePage(idx)} className={`relative aspect-[3/4] rounded-xl overflow-hidden cursor-pointer transition-all duration-200 group ${page.selected ? 'ring-2 ring-violet-500 shadow-lg' : 'opacity-60 grayscale'}`}>
            <div className="absolute inset-0 bg-slate-900">{page.previewUrl ? <img src={page.previewUrl} className="w-full h-full object-contain" /> : <div className="w-full h-full bg-slate-800 flex items-center justify-center"><RefreshCw className="animate-spin text-slate-600"/></div>}</div>
            <div className={`absolute top-2 right-2 w-7 h-7 rounded-full flex items-center justify-center ${page.selected ? 'bg-violet-600 text-white' : 'bg-slate-700 text-slate-400'}`}>{page.selected ? <Check size={14} strokeWidth={3} /> : <X size=
